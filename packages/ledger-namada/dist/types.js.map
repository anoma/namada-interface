{"version":3,"file":"types.js","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":";;;AAkEA,MAAa,SAAS;IAUpB,YAAY,SAAsB;QAChC,IAAI,SAAS,IAAI,IAAI,EAAE,CAAC;YACtB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAA;YACrB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;YAC7B,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;YAC/B,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;YACpC,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;YACnC,IAAI,CAAC,iBAAiB,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;YACxC,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;YAClC,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;QACxC,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAA;YACpB,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,CAAA;YAC9B,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC,QAAQ,CAAA;YAClC,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC,aAAa,CAAA;YAC5C,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC,YAAY,CAAA;YAC1C,IAAI,CAAC,iBAAiB,GAAG,SAAS,CAAC,iBAAiB,CAAA;YACpD,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC,WAAW,CAAA;YACxC,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC,eAAe,CAAA;QAClD,CAAC;IACH,CAAC;CACF;AA/BD,8BA+BC","sourcesContent":["import { LedgerError } from './common'\n\nexport interface ResponseBase {\n  errorMessage: string\n  returnCode: LedgerError\n}\n\nexport interface ResponseAddress extends ResponseBase {\n  publicKey: Buffer\n  address: Buffer\n}\n\nexport interface ResponseVersion extends ResponseBase {\n  testMode: boolean\n  major: number\n  minor: number\n  patch: number\n  deviceLocked: boolean\n  targetId: string\n}\n\nexport interface ResponseAppInfo extends ResponseBase {\n  appName: string\n  appVersion: string\n  flagLen: number\n  flagsValue: number\n  flagRecovery: boolean\n  flagSignedMcuCode: boolean\n  flagOnboarded: boolean\n  flagPINValidated: boolean\n}\n\nexport interface ResponseDeviceInfo extends ResponseBase {\n  targetId: string\n  seVersion: string\n  flag: string\n  mcuVersion: string\n}\n\nexport interface ResponseShieldedAddress extends ResponseBase {\n  raw_pkd: Buffer\n  bech32m_len: number\n  bech32m_addr: Buffer\n}\n\nexport interface ResponseIncomingViewingKey extends ResponseBase {\n  raw_ivk: Buffer\n}\n\nexport interface ResponseOutgoingViewingKey extends ResponseBase {\n  raw_ovk: Buffer\n}\n\nexport interface ResponseNullifier extends ResponseBase {\n  raw_nf: Buffer\n}\n\nexport interface ISignature {\n  pubkey: Buffer\n  raw_salt: Buffer\n  raw_signature: Buffer\n  wrapper_salt: Buffer\n  wrapper_signature: Buffer\n  raw_indices: Buffer\n  wrapper_indices: Buffer\n}\nexport class Signature implements ISignature {\n  pubkey: Buffer\n  raw_salt: Buffer\n  raw_signature: Buffer\n  wrapper_salt: Buffer\n  wrapper_signature: Buffer\n  raw_indices: Buffer\n  wrapper_indices: Buffer\n  isFilled: boolean\n\n  constructor(signature?: ISignature) {\n    if (signature == null) {\n      this.isFilled = false\n      this.pubkey = Buffer.from([])\n      this.raw_salt = Buffer.from([])\n      this.raw_signature = Buffer.from([])\n      this.wrapper_salt = Buffer.from([])\n      this.wrapper_signature = Buffer.from([])\n      this.raw_indices = Buffer.from([])\n      this.wrapper_indices = Buffer.from([])\n    } else {\n      this.isFilled = true\n      this.pubkey = signature.pubkey\n      this.raw_salt = signature.raw_salt\n      this.raw_signature = signature.raw_signature\n      this.wrapper_salt = signature.wrapper_salt\n      this.wrapper_signature = signature.wrapper_signature\n      this.raw_indices = signature.raw_indices\n      this.wrapper_indices = signature.wrapper_indices\n    }\n  }\n}\n\nexport interface ResponseSign extends ResponseBase {\n  signature?: Signature\n}\n"]}