{"version":3,"file":"processResponses.js","sourceRoot":"","sources":["../src/processResponses.ts"],"names":[],"mappings":"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","sourcesContent":["/** ******************************************************************************\n *  (c) 2018 - 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ******************************************************************************* */\n\nimport { errorCodeToString } from './common'\nimport { HASH_LEN, PK_LEN_25519, SALT_LEN } from './config'\nimport { ISignature } from './types'\n\nexport function processGetSignatureResponse(response: Buffer): ISignature {\n  console.log('Processing get signature response')\n\n  let offset = 0\n  const salt = Buffer.from(response.subarray(offset, offset+SALT_LEN))\n  offset += SALT_LEN\n  const hashesLen = response[offset] + response[offset+1]*0x100 + response[offset+2]*0x10000 + response[offset+3]*0x1000000\n  offset += 4\n  const hashes = []\n  for (let i = 0; i < hashesLen; i ++) {\n    hashes.push(Buffer.from(response.subarray(offset, offset+HASH_LEN)))\n    offset += HASH_LEN\n  }\n  const pubkey = Buffer.from(response.subarray(offset, offset + PK_LEN_25519+1))\n  offset += PK_LEN_25519+1\n  const hasSignature = response[offset]\n  offset += 1\n  let signature = null\n  if(hasSignature) {\n    signature = Buffer.from(response.subarray(offset, offset + 65))\n    offset += 65\n  }\n  const raw = Buffer.from(response.subarray(0, offset))\n\n  return {\n    salt,\n    hashes,\n    pubkey,\n    signature,\n    raw,\n  }\n}\n\nexport function processGetAddrResponse(response: Buffer) {\n  console.log('Processing get address response')\n\n  let partialResponse = response\n\n  const errorCodeData = partialResponse.subarray(-2)\n  const returnCode = errorCodeData[0] * 256 + errorCodeData[1]\n\n  //get public key len (variable)\n  const publicKey = Buffer.from(partialResponse.slice(0, PK_LEN_25519))\n\n  //\"advance\" buffer\n  partialResponse = partialResponse.slice(PK_LEN_25519)\n\n  // get the implicit address corresponding to the public key\n  const address = Buffer.from(partialResponse.slice(0, -2))\n\n  return {\n    publicKey,\n    address,\n    returnCode,\n    errorMessage: errorCodeToString(returnCode),\n  }\n}\n\n// Not used yet\n// function processGetShieldedAddrResponse(response: Buffer) {\n//   console.log(\"Processing get address response\")\n\n//   let partialResponse = response\n\n//   const errorCodeData = partialResponse.slice(-2)\n//   const returnCode = errorCodeData[0] * 256 + errorCodeData[1]\n\n//   //get public key len (variable)\n//   const raw_pkd = Buffer.from(partialResponse.slice(0, 32))\n\n//   //\"advance\" buffer\n//   partialResponse = partialResponse.slice(32)\n\n//   // get the length of the bech32m address\n//   const bech32m_len = partialResponse[0]\n\n//   //\"advance\" buffer\n//   partialResponse = partialResponse.slice(1)\n\n//   // get the bech32m encoding of the shielded address\n//   const bech32m_addr = Buffer.from(partialResponse.slice(0, bech32m_len))\n\n//   return {\n//     raw_pkd,\n//     bech32m_len,\n//     bech32m_addr,\n//     returnCode,\n//     errorMessage: errorCodeToString(returnCode),\n//   }\n// }\n\n// function processIncomingViewingKeyResponse(response: Buffer) {\n//   console.log(\"Processing get IVK response\")\n\n//   const partialResponse = response\n\n//   const errorCodeData = partialResponse.slice(-2)\n//   const returnCode = errorCodeData[0] * 256 + errorCodeData[1]\n\n//   //get public key len (variable)\n//   const raw_ivk = Buffer.from(partialResponse.slice(0, 32))\n\n//   return {\n//     raw_ivk,\n//     returnCode,\n//     errorMessage: errorCodeToString(returnCode),\n//   }\n// }\n\n// function processNullifierResponse(response: Buffer) {\n//   console.log(\"Processing get nullifier response\")\n\n//   const partialResponse = response\n\n//   const errorCodeData = partialResponse.slice(-2)\n//   const returnCode = errorCodeData[0] * 256 + errorCodeData[1]\n\n//   const raw_nf = Buffer.from(partialResponse.slice(0, 32))\n\n//   return {\n//     raw_nf,\n//     returnCode,\n//     errorMessage: errorCodeToString(returnCode),\n//   }\n// }\n\n// function processOutgoingViewingKeyResponse(response: Buffer) {\n//   console.log(\"Processing get OVK response\")\n\n//   const partialResponse = response\n\n//   const errorCodeData = partialResponse.slice(-2)\n//   const returnCode = errorCodeData[0] * 256 + errorCodeData[1]\n\n//   //get public key len (variable)\n//   const raw_ovk = Buffer.from(partialResponse.slice(0, 32))\n\n//   return {\n//     raw_ovk,\n//     returnCode,\n//     errorMessage: errorCodeToString(returnCode),\n//   }\n// }\n"]}