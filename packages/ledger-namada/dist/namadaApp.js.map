{"version":3,"file":"namadaApp.js","sourceRoot":"","sources":["../src/namadaApp.ts"],"names":[],"mappings":"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","sourcesContent":["/** ******************************************************************************\n *  (c) 2018 - 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ******************************************************************************* */\nimport Transport from '@ledgerhq/hw-transport'\nimport { ResponseAddress, ResponseAppInfo, ResponseBase, ResponseSign, ResponseVersion } from './types'\n\nimport {\n  CHUNK_SIZE,\n  errorCodeToString,\n  LedgerError,\n  P1_VALUES,\n  PAYLOAD_TYPE,\n  processErrorResponse,\n  serializePath,\n} from './common'\n\nimport { CLA, INS } from './config'\nimport { getSignatureResponse, processGetAddrResponse } from './processResponses'\n\nexport { LedgerError }\nexport * from './types'\n\nexport class NamadaApp {\n  transport: Transport\n\n  constructor(transport: Transport) {\n    if (!transport) {\n      throw new Error('Transport has not been defined')\n    }\n\n    this.transport = transport\n  }\n\n  async prepareChunks(serializedPath: Buffer, message: Buffer) {\n    const chunks = []\n\n    chunks.push(serializedPath)\n    for (let i = 0; i < message.length; i += CHUNK_SIZE) {\n      let end = i + CHUNK_SIZE\n      if (i > message.length) {\n        end = message.length\n      }\n      chunks.push(message.subarray(i, end))\n    }\n\n    return chunks\n  }\n\n  async getVersion(): Promise<ResponseVersion> {\n    return this.transport.send(CLA, INS.GET_VERSION, 0, 0).then((response: any) => {\n      const errorCodeData = response.slice(-2)\n      const returnCode = errorCodeData[0] * 256 + errorCodeData[1]\n\n      let targetId = 0\n      if (response.length >= 9) {\n        /* eslint-disable no-bitwise */\n        targetId = (response[5] << 24) + (response[6] << 16) + (response[7] << 8) + (response[8] << 0)\n        /* eslint-enable no-bitwise */\n      }\n\n      return {\n        returnCode: returnCode,\n        errorMessage: errorCodeToString(returnCode),\n        // ///\n        testMode: response[0] !== 0,\n        major: response[1],\n        minor: response[2],\n        patch: response[3],\n        deviceLocked: response[4] === 1,\n        targetId: targetId.toString(16),\n      }\n    }, processErrorResponse)\n  }\n\n  async getAppInfo(): Promise<ResponseAppInfo> {\n    return this.transport.send(0xb0, 0x01, 0, 0).then(response => {\n      const errorCodeData = response.slice(-2)\n      const returnCode = errorCodeData[0] * 256 + errorCodeData[1]\n\n      const result: { errorMessage?: string; returnCode?: LedgerError } = {}\n\n      let appName = 'err'\n      let appVersion = 'err'\n      let flagLen = 0\n      let flagsValue = 0\n\n      if (response[0] !== 1) {\n        // Ledger responds with format ID 1. There is no spec for any format != 1\n        result.errorMessage = 'response format ID not recognized'\n        result.returnCode = LedgerError.DeviceIsBusy\n      } else {\n        const appNameLen = response[1]\n        appName = response.slice(2, 2 + appNameLen).toString('ascii')\n        let idx = 2 + appNameLen\n        const appVersionLen = response[idx]\n        idx += 1\n        appVersion = response.slice(idx, idx + appVersionLen).toString('ascii')\n        idx += appVersionLen\n        const appFlagsLen = response[idx]\n        idx += 1\n        flagLen = appFlagsLen\n        flagsValue = response[idx]\n      }\n\n      return {\n        returnCode,\n        errorMessage: errorCodeToString(returnCode),\n        //\n        appName,\n        appVersion,\n        flagLen,\n        flagsValue,\n        flagRecovery: (flagsValue & 1) !== 0,\n        // eslint-disable-next-line no-bitwise\n        flagSignedMcuCode: (flagsValue & 2) !== 0,\n        // eslint-disable-next-line no-bitwise\n        flagOnboarded: (flagsValue & 4) !== 0,\n        // eslint-disable-next-line no-bitwise\n        flagPINValidated: (flagsValue & 128) !== 0,\n      }\n    }, processErrorResponse)\n  }\n\n  async getAddressAndPubKey(path: string): Promise<ResponseAddress> {\n    const serializedPath = serializePath(path)\n    return this.transport\n      .send(CLA, INS.GET_PUBLIC_KEY, P1_VALUES.ONLY_RETRIEVE, 0, serializedPath, [LedgerError.NoErrors])\n      .then(processGetAddrResponse, processErrorResponse)\n  }\n\n  async showAddressAndPubKey(path: string): Promise<ResponseAddress> {\n    const serializedPath = serializePath(path)\n    return this.transport\n      .send(CLA, INS.GET_PUBLIC_KEY, P1_VALUES.SHOW_ADDRESS_IN_DEVICE, 0, serializedPath, [LedgerError.NoErrors])\n      .then(processGetAddrResponse, processErrorResponse)\n  }\n\n  async signSendChunk(chunkIdx: number, chunkNum: number, chunk: Buffer, ins: number): Promise<ResponseBase> {\n    let payloadType = PAYLOAD_TYPE.ADD\n    const p2 = 0\n    if (chunkIdx === 1) {\n      payloadType = PAYLOAD_TYPE.INIT\n    }\n    if (chunkIdx === chunkNum) {\n      payloadType = PAYLOAD_TYPE.LAST\n    }\n\n    return this.transport\n      .send(CLA, ins, payloadType, p2, chunk, [\n        LedgerError.NoErrors,\n        LedgerError.DataIsInvalid,\n        LedgerError.BadKeyHandle,\n        LedgerError.SignVerifyError,\n      ])\n      .then((response: Buffer) => {\n        const errorCodeData = response.subarray(-2)\n        const returnCode = errorCodeData[0] * 256 + errorCodeData[1]\n        let errorMessage = errorCodeToString(returnCode)\n\n        if (\n          returnCode === LedgerError.BadKeyHandle ||\n          returnCode === LedgerError.DataIsInvalid ||\n          returnCode === LedgerError.SignVerifyError\n        ) {\n          errorMessage = `${errorMessage} : ${response.subarray(0, response.length - 2).toString('ascii')}`\n        }\n\n        if (returnCode === LedgerError.NoErrors && response.length > 2) {\n          return {\n            signature: getSignatureResponse(response),\n            returnCode,\n            errorMessage,\n          };\n        }\n\n        return {\n          returnCode: returnCode,\n          errorMessage: errorMessage,\n        } as ResponseSign\n      }, processErrorResponse)\n  }\n\n  async sign(path: string, message: Buffer): Promise<ResponseSign> {\n    const serializedPath = serializePath(path)\n\n    return this.prepareChunks(serializedPath, message).then(chunks => {\n      return this.signSendChunk(1, chunks.length, chunks[0], INS.SIGN).then(async response => {\n        let result: ResponseSign = {\n          returnCode: response.returnCode,\n          errorMessage: response.errorMessage,\n        }\n\n        for (let i = 1; i < chunks.length; i++) {\n          result = await this.signSendChunk(1 + i, chunks.length, chunks[i], INS.SIGN)\n          if (result.returnCode !== LedgerError.NoErrors) {\n            break\n          }\n        }\n        return result\n      }, processErrorResponse)\n    }, processErrorResponse)\n  }\n\n  /* Not implemented yet\n  async getShieldedAddressAndPubKey(path: number, div: Buffer): Promise<ResponseShieldedAddress> {\n    const buf = Buffer.alloc(4);\n    buf.writeUInt32LE(path, 0);\n    return this.transport\n        .send(CLA, INS.GET_MASP_ADDRESS, P1_VALUES.ONLY_RETRIEVE, 0, Buffer.concat([buf, div]), [LedgerError.NoErrors])\n        .then(processGetShieldedAddrResponse, processErrorResponse)\n  }\n\n  async showShieldedAddressAndPubKey(path: number, div: Buffer): Promise<ResponseShieldedAddress> {\n    const buf = Buffer.alloc(4);\n    buf.writeUInt32LE(path, 0);\n    return this.transport\n        .send(CLA, INS.GET_MASP_ADDRESS, P1_VALUES.SHOW_ADDRESS_IN_DEVICE, 0, Buffer.concat([buf, div]), [LedgerError.NoErrors])\n        .then(processGetShieldedAddrResponse, processErrorResponse)\n  }\n\n  async getIncomingViewingKey(path: number): Promise<ResponseIncomingViewingKey> {\n    const buf = Buffer.alloc(4);\n    buf.writeUInt32LE(path, 0);\n    return this.transport\n        .send(CLA, INS.GET_IVK, P1_VALUES.SHOW_ADDRESS_IN_DEVICE, 0, buf, [LedgerError.NoErrors])\n        .then(processIncomingViewingKeyResponse, processErrorResponse)\n  }\n\n  async getOutgoingViewingKey(path: number): Promise<ResponseOutgoingViewingKey> {\n    const buf = Buffer.alloc(4);\n    buf.writeUInt32LE(path, 0);\n    return this.transport\n        .send(CLA, INS.GET_OVK, P1_VALUES.SHOW_ADDRESS_IN_DEVICE, 0, buf, [LedgerError.NoErrors])\n        .then(processOutgoingViewingKeyResponse, processErrorResponse)\n  }\n\n  async getNullifier(pos: Uint8Array, cm: Buffer): Promise<ResponseNullifier> {\n    return this.transport\n        .send(CLA, INS.GET_NF, P1_VALUES.ONLY_RETRIEVE, 0, Buffer.concat([pos, cm]), [LedgerError.NoErrors])\n        .then(processNullifierResponse, processErrorResponse)\n  }\n  */\n}\n"]}